#  DP(Dynamic Programming)

## 개요

- DP는 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것이다.

- `큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용`한다. 그래서 혹자는 DP가 아닌 `기억하며 풀기`라고 부르기도 한다.

----------------
## DP를 쓰는 이유 

- `일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산`이 될 수 있다는 것이다.

- 예를 들어 피보나치 수열을 살펴보자. 피보나치 수열은 아래와 같다.
- 1,  1,  2,  3,  5,  8,  13,  21,  34,  55,  89,  144, ...

- 피보나치 수를 재귀로 표현하면 `f(n) = f(n-1) + f(n-2)` 이다.

- 그런데 f(n-1), f(n-2)에서 각 함수를 1번씩 호출하면 동일한 값을 2번씩 구하게 되고 이로 인해 100번째 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수적으로 증가한다.

- 왜냐하면, f(n-1)에서 한 번 구한 값을 f(n-2)에서 또 다시 같은 값을 구하는 과정을 반복하게 되기 때문이다. 아래의 그림처럼 반복되는 계산을 또 하게 된다.

<img width="530" alt="피보나치3" src="https://github.com/monghwadang/2024-CS-Study/assets/156163400/2b55e084-2643-4b9c-baee-fb61d24f6d34">
 
- 그러나 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용 한다면 앞에서 계산된 값을 다시 반복할 필요가 없어진다.

- 즉, 매우 효율적으로 문제를 해결할 수 있게 된다. 시간복잡도를 기준으로 아래와 같이 개선이 가능하다.
`O(n^2) → O(f(n))` 로 개선 (다항식 수준으로, 문제에 따라 다름.)

-----------------
## DP의 사용 조건
 
DP가 적용되기 위해서는 `2가지 조건`을 만족해야 한다.

    1) Overlapping Subproblems(겹치는 부분 문제)
    2) Optimal Substructure(최적 부분 구조)

### ① Overlapping Subproblems(겹치는 부분 문제)

- DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 `동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능`하다.

- 즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 `부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능`하니 `부분 문제가 중복되지 않는 경우에는 사용할 수 없다.`

### ② Optimal Substructure(최적 부분 구조)

- `부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우`를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다.

- 부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다.

- 피보나치 수열도 동일하게 이전의 계산 값을 그대로 사용하여 전체 답을 구할 수 있어 최적 부분 구조를 갖고 있다.

-------------
## DP 사용하기
 
- DP를 적용할 수 있는 문제인지를 알아내는 것부터 코드를 짜는 과정이 난이도가 쉬운 것부터 어려운 것까지 다양하다.

일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.

    1) DP로 풀 수 있는 문제인지 확인
    2) 문제의 변수 파악
    3) 변수 간 관계식 만들기(점화식)
    4) 메모하기(memoization or tabulation)
    5) 기저 상태 파악
    6) 구현하기

 

### ① DP로 풀 수 있는 문제인지 확인

- 애초에 이 부분 부터 해결이 매우 어렵다. 우선 DP의 조건 부분에서 써내렸듯이, 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단해야 한다.

- 즉, 위에서 쓴 `조건들이 충족되는 문제인지를 한 번 체크`해보는 것이 좋다.

- 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

### ② 문제의 변수 파악

- DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아내야 한다.

- 예를 들어, 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 `n이 변수`가 된다. 그 변수가 얼마냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.

### ③ 변수 간 관계식 만들기

- 변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.

- 그러한 식을 `점화식`이라고 부르며 그를 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.

- 예를 들어 피보나치 수열에서는 `f(n) = f(n-1) + f(n-2)` 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.

### ④ 메모하기

- 변수 간 관계식까지 정상적으로 생성되었다면 `변수의 값에 따른 결과를 저장`해야 한다. 이것을 메모한다고 하여 `Memoization`이라고 부른다.

- 변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

- 이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

### ⑤ 기저 상태 파악

- 여기까지 진행했으면, `가장 작은 문제의 상태`를 알아야 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다. 

- 피보나치 수열을 예시로 들면, `f(0) = 0, f(1) = 1`과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.

- 해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.

### ⑥ 구현하기

DP는 2가지 방식으로 구현할 수 있다.

    1) Bottom-Up (Tabulation 방식) - 반복문 사용
    2) Top-Down (Memoization 방식) - 재귀 사용

### ⑥-① Bottom-Up 방식

- 이름에서 보이듯이, `아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식`이다.

- Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

- 사실 위에서 메모하기 부분에서 Memoization이라고 했는데 `Bottom-up일 때는 Tabulation`이라고 부른다.

- 왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 `"table-filling"` 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 `Tabulation`이라는 명칭이 붙었다고 한다.

- 사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

### ⑥-② Top-Down 방식

- 이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 `위에서 부터 바로 호출을 시작`하여 dp[0]의 상태까지 내려간 다음 해당 `결과 값을 재귀를 통해 전이시켜 재활용`하는 방식이다.

- 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 `Memoization` 이라고 부른다.

```java
public class Fibonacci{
    // DP 를 사용 시 작은 문제의 결과값을 저장하는 배열
    // Top-down, Bottom-up 별개로 생성하였음
    static int[] topDown_memo; 
    static int[] bottomUp_table;
    public static void main(String[] args){
        int n = 30;
        topDown_memo = new int[n+1];
        bottomUp_table = new int[n+1];
        
        System.out.println(naiveRecursion(n));
        
        System.out.println();
        
        System.out.println(topDown(n));
        
        System.out.println();
        
        System.out.println(bottomUp(n));
    }
    
    // 단순 재귀를 통해 Fibonacci를 구하는 경우
    // 동일한 계산을 반복하여 비효율적으로 처리가 수행됨
    public static int naiveRecursion(int n){
        if(n <= 1) return n;
        return naiveRecursion(n-1) + naiveRecursion(n-2);
    }
    
    // DP Top-Down을 사용해 Fibonacci를 구하는 경우
    public static int topDown(int n){
        // 기저 상태 도달 시, 0, 1로 초기화
        if(n < 2) return topDown_memo[n] = n;
        
        // 메모에 계산된 값이 있으면 바로 반환
        if(topDown_memo[n] > 0) return topDown_memo[n];
        
        // 재귀를 사용하고 있음
        topDown_memo[n] = topDown(n-1) + topDown(n-2);
        
        return topDown_memo[n];
    }
    
    // DP Bottom-Up을 사용해 Fibonacci를 구하는 경우
    public static int bottomUp(int n){
        // 기저 상태의 경우 사전에 미리 저장
        bottomUp_table[0] = 0;
        bottomUp_table[1] = 1;
        
        // 반복문을 사용하고 있음
        for(int i=2; i<=n; i++){
            // Table을 채워나감
            bottomUp_table[i] = bottomUp_table[i-1] + bottomUp_table[i-2];
        }
        return bottomUp_table[n];
    }
}
``` 
-----------
## 기타 내용
 
- 두 가지 방법(Top-Down vs Bottom-Up) 중 더 나은 것이 있는지, 하나만 가능한 경우가 있는지?

    - 두 방법 중 `어느 것이 시간적으로 더 효율이 있는지는 알 수 없다.`

    - 또한, 2가지 방법 중 2가지를 모두 사용하지는 못하고 `하나만 사용할 수 있는 경우도 있다.`


-  Divide and Conquer(분할 정복)와 차이점은?

    - 분할 정복과 동적 프로그래밍은 `주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점`은 같다.

    - 차이점은, `분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우`에 쓰며, `동일한 중복이 일어나면 동적 프로그래밍`을 쓴다는 것이다.