
-------------------------------------
# 연산장치(ALU, Arithmetic Logic Unit)

![alu](https://github.com/monghwadang/2024-CS-Study/assets/156163400/831f13b4-674b-4f78-942b-3e94f69af5a3)

- CPU에서 제어장치의 명령에 따라 실제로 연산을 수행하는 장치

- ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치(CU)로부터 수행할 연산을 알려주는 제어신호를 받아들여 다양한 연산을 수행한다.

- 연산 후에 ALU는 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장하고 연산결과에 대한 추가적인 상태 정보인 플래그(flag)를 플래그 레지스터로 내보낸다.

## 연산장치 구성요소

### 1. 가산기(Adder)

- 산술연산을 수행하는 회로, 두 개이상의 수의 합을 계산하는 논리 회로

### 2. 보수기(Complementer)

- 뺄셈을 사용할 때 사용하는 보수를 만들어주는 논리 회로

### 3. 시프터(Shifter)

- 2진수의 각 자리를 왼쪽 또는 오른쪽으로 이동해주는 회로

### 4. 오버플로우 검출기(Overflow)

- 산술기의 결과가 해당 레지스터의 용량을 초과했을 때를 검출해주는 회로

### 5. 데이터 레지스터(Data Register)

- 연산을 위한 데이터를 일시적으로 기억하는 레지스터

## 연산장치 명령어 수행 과정

![연산장치작동](https://github.com/monghwadang/2024-CS-Study/assets/156163400/ce38f543-2d60-4e26-bd53-064100ca1b0f)

① 레지스터 또는 기억장치에서 데이터를 가져온다.

② ALU에서 명령어에 따른 연산을 수행한다.

③ 연산의 결과값을 누적기(Accumulator)에 저장한다.

## 플래그(flag)

- ALU가 처리한 연산결과에 대한 추가적인 상태 정보

- CPU가 프로그램을 실행하는 도중에 반드시 기억해야되는 일종의 참고 정보라고 생각하면 된다.

![플래그래지스터](https://github.com/monghwadang/2024-CS-Study/assets/156163400/1f0cbb66-25a8-4d0a-96bd-e1d9ab244727)

|종류|의미|사용 예시|
|------|---|---|
|부호 플래그|연산한 결과의 부호를 나타낸다.|부호플래그가 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수를 의미한다.|
|제로 플래그|연산 결과가 0인지 여부를 나타낸다.|제로 플래그가 1일 경우 연산 결과는 0, 0일경우 연산결과는 0이 아님을 의미한다.|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.|캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.|
|`오버플로우` 플래그|오버플로우가 발생했는지를 나타낸다.|오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고 0일 경우 발생하지 않았음을 의미한다.|
|`인터럽트` 플래그|인터럽트가 가능한지를 나타낸다.|인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미하고 0일 경우 인터럽트가 불가능함을 의미한다.|
|`슈퍼바이저` 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.|슈퍼바이저 플래그가 1일 경우 커널모드로 실행 중임을 의미하고, 0일 경우 사용자 모드로 실행 중임을 의미한다.|

> ### 오버플로우(overflow)
> 연산결과가 연산 결과를 담은 레지스터보다 큰 상황

> ### 인터럽트(interupt)
> CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능

> ### 슈퍼바이저(supervisor mode)
> 운영체제에 커널이 동작되는 모드

---------------------------
# 제어장치(CU, Control Unit)

- 제어 신호(Control Signal)를 통해서 명령어를 해석, 조작을 지시하는 장치

- 컴퓨터 부품을 관리하고 작동시키기 위한 일종의 전기 신호

![제어장치](https://github.com/monghwadang/2024-CS-Study/assets/156163400/a8a8eb9e-64a1-4234-a3ad-609f0da413fb)

## 제어장치 구성 요소

### 1. 주소 레지스터(MAR, Memory Address Register)

- 주기억 장치에 명령이나 자료가 기억되어 있는 주소를 보관한다.

### 2. 기억 레지스터(MBR, Memory Buffer Register)

- 명령어 계수기(PC)가 지정하는 주기억 장치의 내용을 임시로 보관한다.

### 3. 명령어 레지스터(IR, Instruction Register)

- 현재 실행 중인 명령을 기억하는 레지스터로, 연산 코드와 주소부로 구성한다.

### 4. 명령어 계수기(PC,  Program Counter)

- 다음에 실행할 명령어가 기억되어 있는 주기억 장치의 주소를 기억한다.

### 5. 명령어 해독기(Decoder)

- 명령어 레지스터의 명령 코드를 해독하여 필요한 실행 신호를 발생시킨다.

### 6. 주소 처리기(Address Processor)

- 피연산자를 인출할 경우 그 주소를 계산하거나 수행될 명령 순서가 바뀔 때 다음 수행할 명령의 주소를 계산한다.

### 7. 순서기(Sequencer)

- 정해진 순성 따라 동작 순서를 제어한다.

## 제어장치 명령어 수행 과정

![제어장치작동](https://github.com/monghwadang/2024-CS-Study/assets/156163400/f3b9e36e-7753-4558-8e40-282fcc7101c7)

① PC에 저장된 주소를 MAR로 보낸다.

② MAR에 저장된 주소에 있는 기억장치의 명령어를 MBR로 읽어 오고, PC를 증가시킨다. 명령어의 실행을 위해 읽어 온 명령을 IR에 저장한다.

③ 명령어의 연산코드는 명령어 해독기로 보내고 오퍼랜드는 주소처리기로 보낸다.

④ 주소처리기는 MAR을 통해 기억장치에 접근하여 명령어 수행에 필요한 오퍼랜드의 주소 또는 다음 명령어의 주소를 계산한다.

⑤ 제어신호 발생기에서는 위의 ①~④ 과정에서 필요한 제어신호와 연산코드를 해독하여 명령 수행을 위한 제어신호를 발생시킨다.  
이때 명령어가 기억장치의 주소를 참조하는 명령어라면 주소처리기를 동작시켜 다음에 수행될 명령어의 주소를 계산한다.

⑥ 현재 IR에 있는 명령어의 수행이 끝나면 증가된 PC의 내용은 다음에 수행할 명령어의 주소를 지정하거나 분기가 필요한 경우 해당 명령어의 주소를 지정하는데 이는 다시 ①부터의 과정을 반복하며 실행된다.

## 제어장치의 입력

### 1. 클럭 신호

![클럭](https://github.com/monghwadang/2024-CS-Study/assets/156163400/72ee5649-b947-40e2-8804-cb7386813a22)

- 클럭(clock)이란 논리상태 H(high, 논리 1)와 L(low, 논리 0)이 주기적으로 나타나는 신호이다.

- 많은 경우 디지털 회로에서 클럭 신호에 맞추어 신호의 처리를 하는 동기 처리를 위해 사용한다.

### 2. 해석할 명령어

- CPU가 해석해야 하는 명령어는 명령어 레지스터에 저장된다.

- 명령어 레지스터로부터 명령어를 받아서 해석한 후 제어 신호를 발생해 수행할 내용을 전달한다.

### 3. 플래그 레지스터 속 플래그 값

- 플래그는 ALU 연산에 대한 추가 상태 정보이므로 제어장치의 명령어 해석에 필요한 추가 정보이다.

### 4. 제어 버스로 전달된 제어 신호

- 제어신호는 CPU 뿐만 아니라 다른 외부 장치에서도 발생시킬 수 있어 해당 정보를 받아들인다.

## 제어장치의 출력

### 1. CPU 외부

- CPU 외부로 메모리나 입출력장치의 값을 읽거나 쓰기 위해서 제어신호를 전달한다.


### 2. CPU 내부

- CPU 내부로 ALU나 레지스터의 동작을 지시하기 위해서 제어신호를 내보낸다.

-------------------
# 레지스터(Register)

- CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치

- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장되기 때문에 레지스터만 잘 관찰해도 프로그램의 자세한 실행 과정을 알 수 있다.

## 레지스터의 종류

### 1. 프로그램 카운터(PC, Program Counter)

- 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.

- 명령어 포인터(IP, Instruction Pointer)라고도 부른다.

### 2. 명령어 레지스터(IR, Instruction Register)

- 메모리에서 읽어 들인 해석할 명령어를 저장한다.

- 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

### 3. 메모리 주소 레지스터(MAR, Memory Address Register)

- 메모리의 주소를 저장한다.

- CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 거치게 된다.

### 4. 메모리 버퍼 레지스터(MBR, Memory Buffer Register)

- 메모리와 주고 받을 데이터나 명령어를 저장한다.

- 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.

- CPU가 주소 버스로 내보낼 값이 MAR를 거친다면, 데이터 버스로 주고 받을 값은 MBR를 거친다.

- 메모리 데이터 레지스터(MDR, Memory Data Register)라고도 부른다.

## 레지스터 작동 방식

![레지스터1](https://github.com/monghwadang/2024-CS-Study/assets/156163400/e7eaa965-7c2e-4325-948e-990873ea27bd)

![레지스터2](https://github.com/monghwadang/2024-CS-Study/assets/156163400/72f2b183-3df4-4a37-b2d3-710e1acc8423)

![레지스터3](https://github.com/monghwadang/2024-CS-Study/assets/156163400/42aef84e-c11a-435a-9fae-f4b0a1a64527)

![레지스터4](https://github.com/monghwadang/2024-CS-Study/assets/156163400/463f1ed3-a7cc-4424-bb67-519156ccadce)

![레지스터5](https://github.com/monghwadang/2024-CS-Study/assets/156163400/fc47bc0b-d46e-4b99-8473-b2a70f0f4eb1)

![레지스터6](https://github.com/monghwadang/2024-CS-Study/assets/156163400/87e7b63a-3b9e-49b5-a2b5-0c8ba3977863)

![레지스터7](https://github.com/monghwadang/2024-CS-Study/assets/156163400/ba24f11d-5cc4-4249-b0da-9d05d975b31e)

### 5. 범용 레지스터(general purpose register)

- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있다.

- MAR은 주소 버스로 내보낼 주소 값만 MBR은 데이터 버스로 주고 받을 값만 저장하지만, 범용 레지스터는 데이터와 주소 모두를 저장할 수 있다.

- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있다.

### 6. 플래그 레지스터(flag register)

- ALU 연산 결과에 따른 플래그 또는 CPU 상태에 대한 부가적인 정보를 저장한다.

### 7. 스택 포인터(stack pointer)

- 스택 주소 지정 방식을 사용할 때 사용하는 레지스터다.

- 스택에 마지막으로 저장한 값의 위치를 저장한다.

### 8. 베이스 레지스터(base register)

- 베이스 레지스터 주소 지정 방식에서 사용하는 기준 주소를 저장한다.

## 특정 레지스터를 이용한 주소 지정 방식

### 1. 스택 주소 지정 방식

![스택주소2](https://github.com/monghwadang/2024-CS-Study/assets/156163400/d85247fd-0726-4000-929c-c255d7b76a65)

![스택주소](https://github.com/monghwadang/2024-CS-Study/assets/156163400/52b13318-4a19-42f1-b166-9fca27f87d8e)

- 메모리 안에 스택처럼 사용할 영역이 정해져 있는 스택 영역의 주소를 지정하는 방식

### 2. 변위 주소 지정 방식

![변위주소1](https://github.com/monghwadang/2024-CS-Study/assets/156163400/872e4017-19e2-45b3-95b2-9da96918c296)

![변위주소2](https://github.com/monghwadang/2024-CS-Study/assets/156163400/6a2fcdc5-2c68-43b8-a856-94216a83475e)

- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

### 2-1. 상대 주소 지정 방식

![상대주소1](https://github.com/monghwadang/2024-CS-Study/assets/156163400/fc6a796b-cf88-400a-9c97-938c8bed286d)

![상대주소2](https://github.com/monghwadang/2024-CS-Study/assets/156163400/d912e42c-71b9-4f1d-8d0d-946c0f6970fc)

- 오퍼랜드(이동 정도)와 프로그램 카운터(읽어 들일 명령어의 주소)의 값을 더하여 유효 주소를 얻는 방식

- 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용

### 2-2. 베이스 레지스터 주소 지정 방식

![베이스주소](https://github.com/monghwadang/2024-CS-Study/assets/156163400/2f484d77-f536-4d04-b2aa-a5a6326bdecc)

- 오퍼랜드(기존 주소로부터 떨어진 거리)와 베이스 레지스터(기존 주소)의 값을 더하여 유효 주소를 얻는 방식

- 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식

