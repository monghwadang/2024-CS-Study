# 프로세스(Process)

<img width="648" alt="프로세스" src="https://github.com/monghwadang/2024-CS-Study/assets/156163400/3c93b8e7-d38e-474b-97de-e67e4e181a6b">

* 메모리에 적재되고 CPU자원을 할당받아 실행 중에 있는 프로그램

* 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)

* 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라 불린다.

# 프로세스 문맥(context)

* 프로세스가 현재 **어떤 상태**에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보

* 명령을 다시 수행하기 위해서 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 상태를 재현할 수 있는 정보

## 하드웨어 문맥

* CPU의 수행상태를 나타냄

* PC(Program Counter)

* 각종 레지스터(register)

## 프로세스의 주소공간

* 프로세스만의 독자적인 주소공간

* Code 영역

  * 실행할 프로그램의 코드나 명령어들이 기계어 형태로 저장된 영역

  * CPU는 코드영역에 저장된 명령어들을 하나씩 처리한다.

* Data 영역

  * 코드에서 선언한 전역 변수와 정적 변수가 저장되는 영역

  * 프로그램이 실행되면서 할당되고, 종료되면서 소멸한다.

* Stack 영역

  * 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장된다.

  * 함수를 호출하면 기록되고, 종료되면 제거된다.

* Heap 영역

  * 관리가 가능한 데이터 이외의 다른 형태의 데이터(동적 할당 데이터)를 관리하기 위한 자유공간

## 커널상의 문맥

* PCB(Process Control Block)

* Kernel Stack(커널 내의 주소)

# PCB(Process Control Block)

<img width="531" alt="PCB" src="https://github.com/monghwadang/2024-CS-Study/assets/156163400/30d0c030-2d34-47d6-bc06-91f0e6f34887">

* 운영체제가 각 프로세스를 관리하기 위해 유지하고 있는 프로세스 정보들을 담는 커널 내의 자료 구조

* OS가 관리상 사용하는 정보

  * Process state, Process ID

  * Scheduling information, Priority

* CPU 수행 관련 하드웨어 값

  * PC(Program Counter), Register

* 메모리 관련

  * Code, Stack, Data의 위치 정보

* 파일 관련

  Open file descriptors 등

# 프로세스의 상태(State)

![process_state](https://github.com/monghwadang/2024-CS-Study/assets/156163400/c2bacd72-c9e2-4778-8468-fc2fc5092bd1)

* 프로세스는 상태(State)가 변경되며 수행된다.

* running

  * CPU를 잡고 instruction(기계어 명령)을 수행중인 상태

* ready

  * CPU를 기다리는 상태

* blocked (waiting, sleep)

  * CPU를 주어도 당장 instruction을 수행할 수 없는 상태

  * Process 자신이 요청한 event(예 : I/O)가 즉시 만족되지 않아, 이를 기다리는 상태

  * 예) 디스크에서 파일을 읽어와야 하는 경우

* New

  * 디스크에서 메모리로 프로그램이 올라가 실행 준비를 하는 상태

* Terminated

  * Execution(수행)이 끝난 상태

# 문맥 교환(Context Switch)

![문맥교환o](https://github.com/monghwadang/2024-CS-Study/assets/156163400/95565769-6d25-423e-a22a-ab537c75d76e)

* 하나의 프로세스가 이미 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하기 위해 이전 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 적재하는 것

  * 예) 카카오톡을 켜놓고 유튜브로 노래를 들으면서 웹서핑을 하는 것은 사용자 입장에서 동시에 일어나는 일처럼 보이지만 실제로는 그렇지 않음

* 현재 프로세스A가 CPU를 사용하고 있는 상황에서 CPU 사용시간이 끝나 다음 프로세스에게 CPU를 넘겨주어야 한다. 스케쥴링 알고리즘에 의해 다음 CPU를 받을 프로세스B가 선택되었고, 타이머 인터럽트가 발생해 CPU 제어권이 운영체제 커널에 넘어가게 된다.

* 이 과정에서 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행 중이던 프로세스A의 문맥을 자신의 PCB에 저장하고, 프로세스B는 이전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원 시키는 과정을 거치게 된다.

* CPU가 동시에 여러 개의 프로세스를 실행시키는 것처럼 보이지만, 사실은 CPU가 재빠르게 여러 프로세스를 번갈아가며 실행하고 관리하고 있는 것

* 이 때 프로세스를 번갈아가면서 처리하는 것을 문맥 교환(Context Switch)이라고 한다.

## 문맥 교환이 아닌 경우

![문맥교환x](https://github.com/monghwadang/2024-CS-Study/assets/156163400/81a70528-1f5a-4230-a32b-febad3856251)

* 프로세스가 실행 상태일 때, 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 운영체제에게로 넘어와, 원래 실행 중이던 프로세스의 업무를 잠시 멈추고 운영체제의 코드가 실행된다.

* 이는 하나의 프로세스가 사용자 모드에서 실행되다가 커널 모드로 실행 모드만 바뀐 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니다.

## 오버헤드

  * 문맥 교환에 필요한 시간, 메모리

# 멀티태스킹(multi process)

* OS를 통해 CPU가 작업하는데 필요한 자원(시간)을 프로세스 또는 스레드간에 나누는 행위

# 스레드(Thread)

![스레드](https://github.com/monghwadang/2024-CS-Study/assets/156163400/f77eeefa-dbb0-44ae-9f19-90e68ae86e1c)

* 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위

* 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.

* 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고, Code,Data,Heap 영역은 공유한다.

* 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 같은 프로세스 안에 있는 여러 스레드들은 같은 힙공간을 공유한다.

* 스레드가 독립적으로 가지고 있는 부분

  * Program counter (-> 실행 흐름)

  * Register set

  * Stack space

* 스레드가 동료 스레드와 공유하는 부분 (=task)

  * Code section

  * Data section

  * OS Resources

# 프로세스 vs 스레드

![프로세스_스레드](https://github.com/monghwadang/2024-CS-Study/assets/156163400/b7a7d7e5-82cf-4b65-ba92-030d83f79306)

* 운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap의 형식으로 할당한다.

* 각각 독립된 메모리 영역을 할당해주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.

* 이와 다르게, 스레드는 메모리를 서로 공유할 수 있다.

* 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 공유한다.

* 따라서, 각각의 스레드는 별도의 Stack을 가지고 있지만 Heap 메모리는 서로 읽고 쓸 수 있게 된다.

# 멀티 프로세스

* 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것

## 멀티 프로세스의 특징

* 안정성이 좋다. 여러 개의 자식 프로세스 중 하나에 문제가 발생해도, 다른 자식 프로세스에 영향이 확산되지 않는다.

* 구현이 비교적으로 간단하고, 각 프로세스들이 독립적으로 동작하며 자원의 서로 다르게 할단된다.

* 프로세스 간 콩신을 하기 위해서는 IPC를 통해야 한다.

* 메모리 사용량이 많다.

* 스케줄링에 따른 Context Switch이 많아지고, 성능 저하의 우려가 있다.

# 멀티 스레드

* 하나의 프로그램을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것

## 멀티 스레드의 특징

* 응답성이 좋다. 프로그램의 자식 스레드가 오류 또는 긴 작업으로 인해 중단되어도 프로그램이 계속적으로 수행된다.

* 자원 공유가 쉽다. 스레드들은 부모 프로세스의 자원과 메모리를 공유할 수 있다.

* 멀티프로세스 구조에서 각각의 스레드가 다른 프로세스에서 병렬로 수행될 수 있다.

* 구현 및 테스트, 디버깅이 어렵다.

* 너무 많은 스레드 사용은 오버헤드를 발생시킨다.

* 동기화 그리고 교착상태가 발생하지 않도록 주의해야 한다.

* 자식 스레드 중 하나에 문제가 생긴 경우, 전체 프로세스에 영향을 줄 수 있다.
