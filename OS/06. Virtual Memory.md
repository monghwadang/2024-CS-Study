
---------------------
# 가상 메모리 등장 배경

- 컴퓨터의 실제 메모리 공간보다 프로세스가 처리해야할 메모리 공간이 더 많을 수 있다.

- 여러 개의 프로세스를 처리하거나, 메모리가 큰 프로세스를 처리해야할 때의 실행 문제를 해결하기 위해 가상 메모리가 등장하였다.

- 가상 메모리는 물리 메모리보다 큰 프로세스나 여러 개의 프로세스들을 동시에 실행시킬 수 있도록 컴퓨터의 메모리가 무한하다고 느끼게 하는 방법이다.

- 컴퓨터의 실제 메모리 자원은 한정적이지만, 무한한 것처럼 구현하면 다양한 프로세스들을 처리할 수 있다는 점에서 고안된 방법이다.
----------------------------
# 가상 메모리(Virtual Memory)

- 가상 메모리는 `운영체제에서 실제 물리 메모리(RAM)보다 큰 주소 공간을 프로세스에 제공하기 위해 사용되는 기술`이다.

- CPU가 프로세스를 처리할 때, 특정 시점에 프로세스의 특정 메모리를 접근(액세스)하는 주소값이 아주 작다는 점을 착안하여 고안된 방법이다.

- 가상 메모리는 프로세스와 관련된 주소값을 저장하는 메모리 공간을 분리하여 관리함으로써, 내 컴퓨터의 메모리가 실제 메모리보다 많아 보이게 하는 기술이다.

- 가상 메모리에서는 각 데이터 메모리를 페이지 단위로 저장 및 관리하고, 그 페이지의 가상 주소를 물리 주소로 변환해서 실제 물리 데이터에 접근할 수 있다.

---------------------------
# 가상 주소(Virtual Address)

- `프로세스가 참조하는 주소`이다.

- 가상 주소는 프로세스마다 독립적으로 할당 되며, `프로세스는 자신만의 가상 주소 공간`을 가지고 있다고 생각한다.

- 가상 주소는 논리적인 주소이다.  
  운영체제는 프로세스에게 연속된 가상 주소 공간을 제공하고, 이를 필요한 크기의 물리 메모리 페이지로 매핑한다. (메모리 공간 낭비 최소화)

- 가상 주소를 사용하지 않고 프로세스의 모든 데이터들을 물리 주소로 접근한다고 가정하면, 여러 개의 프로세스들이 실행되면서 같은 물리 주소에 접근해서 데이터를 수정하고 민감한 데이터를 쉽게 읽어온다면 오류가 발생할 것이다.

- 프로세스마다 다른 가상 주소를 사용하면 같은 물리 주소 위치를 가리키고 있더라도 읽고 쓰고할 수 있는 공간은 가상 주소 공간으로 제한되므로, 실제 물리 주소의 데이터들이 수정되거나 프로세스들이 동시에 접근해서 충돌하는 일은 없을 것이다.

## 가상 주소 공간 구조

![가상주소공간구조](https://github.com/monghwadang/2024-CS-Study/assets/156163400/b10a3d93-85b4-4b09-86ac-1325cf37dad6)

- Stack : 지역변수, 함수의 매개변수 (함수 실행 시 저장, 종료 시 반환)

- Unused Address Space : 필요할 경우 (런타임 간 저장, 원할 때 반환)

- Heap : 사용자의 동적 할당 (런타임 간 저장, 원할 때 반환)

- Data and BSS : 초기화된 변수(Data), 초기화되지 않은 변수(BSS) (컴파일 시 저장, 프로그램 종료 시 반환)

- Instruction(Code or Text) : 기계어 형태의 실행할 코드 (컴파일 시 저장, 프로그램 종료 시 반환)

----------------------------
# 물리 주소(Physical Address)

- `실제 메모리의 주소`이며 하드웨어에서 직접 접근 가능한 주소이다.

- 시스템 전체적으로 공유되는 주소이며, 여러 프로세스가 공유 메모리 영역을 사용할 때 사용된다.

- 프로세스가 물리 주소로 접근하려면 `물리 주소를 가리키고 있는 가상 주소를 물리 주소로 변환`해야 한다.

---------------------
# 가상 메모리 동작 원리

![가상메모리동작](https://github.com/monghwadang/2024-CS-Study/assets/156163400/e166861e-69b6-42f4-8041-edc8971184a2)

- 프로세스는 생성되면서 일정하게 할당 받은 메모리 공간을 모두 사용하는 것이 아니라, 처리해야할 데이터나 작업에 따라 공간 사용량이 달라진다.

- 이때 프로세스가 차지하는 실제 메모리 공간만 물리 메모리(RAM)에 넣고, 이 물리 메모리에 접근할 수 있는 가상 주소를 프로세스의 메모리에 저장한다.

- 프로세스가 작업을 처리하기 위해 CPU를 호출하고, CPU는 작업을 처리하기 위해 특정 데이터를 조회할 수 있다.

- 특정 데이터가 물리 메모리(RAM) 어디에 있는지는 데이터의 가상 주소를 통해 알 수 있다.

- `프로세스는 CPU에게 작업을 요청할 때 데이터의 가상 주소를 넘긴다`.

- 가상 주소는 실제 물리 주소와 이어져 있지만, 가상 주소가 차지하는 가상 메모리 공간은 아주 작다.

- 실제 데이터는 큰 물리 공간을 차지하고 있겠지만, `가상 메모리로 인해 아주 작은 메모리 공간을 차지하면서 실제 메모리와 연결`되어있는 것이다.

- CPU는 작업을 처리하기 위해 실제 데이터가 어디에 있는지 물리 주소 위치를 알아야하는데, 이때 가상 주소를 물리 주소로 변환하는 작업(MMU)을 거친다.

----------------------------
# MMU(Memory Management Unit)

![MMU](https://github.com/monghwadang/2024-CS-Study/assets/156163400/58df97bb-6815-4886-a125-e7aa53a73847)

- `MMU는 가상 주소를 물리 주소로 변환`하고, `메모리를 보호`하는 기능을 수행한다.

- CPU는 각 물리 메모리에 접근하기 전에 메모리 주소 변환 작업을 거친다.

- MMU는 굉장히 빈번하게 작업을 처리해야 하기 때문에 소프트웨어 코드만으로는 이 작업을 수행하기 벅차다. 그래서 메모리 관리 작업을 하는 특수한 하드웨어를 따로 컴퓨터에 설치해야 한다. (실제로는 작은 칩을 컴퓨터에 꽂아서 사용한다)

- MMU가 메모리를 일일이 가상 주소에서 물리 주소로 변환하게 되면 작업 부하가 높아지므로, 실제 물리 메모리 공간을 여러 페이지 단위로 나눠서 각 `페이지 단위로 데이터를 처리`한다.

- 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리를 구현하는 데 있어서 결정적인 절차이다.

---------------------------
# 요구 페이징(Demand Paging)

![요구 페이징](https://github.com/monghwadang/2024-CS-Study/assets/156163400/37632ea3-7c3a-4dd4-adcf-7da7da8711ad)

- CPU가 요청할 때 `프로세스의 데이터를 메모리에 올리는 것`을 의미한다.

- 처음부터 모든 데이터를 메모리로 적재하지는 않는다.

## 요구 페이징 순서

![요구 페이징 순서](https://github.com/monghwadang/2024-CS-Study/assets/156163400/130a5a38-0555-40eb-b51a-e428c1259dac)

1. CPU가 TLB를 확인한다.

2. TLB에 존재하는 경우(hit) 곧바로 주소를 변환하고, TLB에 없는 경우(miss) page table을 확인한다.

3. page table의 valid-invalid bit가 valid로 되어 있다면 주소를 변환하고 TLB에 page를 올리고, invalid라면 page fault가 발생한다.

4. page fault가 발생하면 MMU가 운영체제에 Trap을 걸고 커널 모드로 들어가서 page fault handler가 Invoke 된다.

5. 운영체제는 page table entry의 정보 속에서 Backing Storage의 어느 위치에 page가 존재하는지 확인한다.

6. 운영체제는 참조된 page를 디스크에서 메모리로 로드하고, dist I/O가 끝날 때까지 이 프로세스는 CPU를 빼앗긴다.

7. dist I/O가 끝나면 page table이 업데이트되고 valid-invalid bit가 valid로 바뀐다. 그리고 ready queue에 프로세스를 넣어준다.

8. CPU가 프로세스 작업을 수행하게 되면 다시 이어서 수행한다.

-------------------------
# 페이지 폴트(Page Faults)

- 프로그램이 `가상 메모리 공간에는 존재하지만 시스템의 물리 메모리 공간에는 존재하지 않는 데이터에 접근`을 시도할 경우 발생하는 현상이다.

- 페이지 폴트가 발생하면 운영체제가 그 데이터를 메모리로 가져와서, 마치 페이지 폴트가 발생하지 않은 것철머 프로그램이 계속적으로 작동하도록 동일한 명령을 수행한다.

- 페이지 폴트가 일어나면 운영체제의 성능이 저하된다.

- 페이지 폴트를 최소화하기 위한 방법으로는 `페이지 교체 정책(Page Replacement Policy)`이 있다.

## 페이지 교체 정책(Page Replacement Policy)

- 메모리가 꽉 차있을 때 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고 새로운 페이지를 방금 비워진 해당 물리 메모리 공간에 올린다.

- 이때 기존 페이지 중 어떤 것을 내리면 좋을지에 대한 알고리즘을 `페이지 교체 알고리즘`이라고 한다.

---------------------------------------------------
# TLB(Translation Lookaside Buffer, 페이지 정보 캐시)

- TLB는 가상 메모리 주소를 물리적 주소로 `변환하는 속도를 높이기 위해` 사용하는 캐시이다.

- 최근에 일어난 `가상 메모리와 물리 주소의 변환 테이블을 저장`한다.

- CPU가 가장 주소를 가지고 메모리에 접근하려고 할 때 먼저 TLB에 접근하여 가상 주소에 해당되는 물리 주소를 찾는다.

- 만약 TLB에 매핑이 존재하지 않는다면 MMU가 페이지 테이블에서 해당되는 물리 주소로 변환한 후 메모리에 접근하게 된다.

- TLB를 사용하면 메모리에 두 번 들를 필요 없이, 바로 해당 물리 주소를 찾아갈 수 있다.

---------------
- 보다 상세한 설명 : https://velog.io/@redgem92/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC